import asyncio
import datetime
import os
import smtplib
import traceback
from email.mime.text import MIMEText
from email.header import Header

# 尝试导入搜索服务，如果项目依赖未安装会报错
try:
    from search_service import SearchService
except ImportError:
    print("错误: 无法导入 SearchService，请检查 search_service.py 是否存在或依赖是否安装")
    exit(1)

# --- 1. 独立定义的 HTML 邮件发送函数 (避免依赖 notification.py) ---
def send_html_email_direct(title, html_content):
    sender = os.getenv("EMAIL_SENDER")
    password = os.getenv("EMAIL_PASSWORD")
    receivers_str = os.getenv("EMAIL_RECEIVERS")
    
    if not sender or not password or not receivers_str:
        print("错误: 邮件配置缺失 (EMAIL_SENDER/PASSWORD/RECEIVERS)")
        return

    receivers = receivers_str.split(",")
    
    message = MIMEText(html_content, 'html', 'utf-8')
    message['From'] = Header(sender)
    message['To'] = Header(",".join(receivers))
    message['Subject'] = Header(title, 'utf-8')

    try:
        # 尝试连接常见 SMTP 端口，根据你的邮箱服务商可能需要调整
        # QQ邮箱/网易邮箱通常使用 SSL 465
        smtp_server = "smtp.qq.com" if "@qq.com" in sender else "smtp.163.com"
        # 如果是 Gmail 或其他，可能需要修改这里
        
        print(f"正在连接邮件服务器: {smtp_server}...")
        server = smtplib.SMTP_SSL(smtp_server, 465)
        server.login(sender, password)
        server.sendmail(sender, receivers, message.as_string())
        server.quit()
        print("邮件发送成功！")
    except Exception as e:
        print(f"邮件发送失败: {e}")
        # 不抛出异常，避免整个脚本红灯，但会打印错误

# --- 2. 独立的 LLM 调用逻辑 (适配 Gemini/OpenAI) ---
# 避免直接从 analyzer.py 导入对象导致的 ImportError
async def generate_summary_with_llm(prompt):
    gemini_key = os.getenv("GEMINI_API_KEY")
    openai_key = os.getenv("OPENAI_API_KEY")
    
    # 优先尝试 Gemini
    if gemini_key:
        try:
            import google.generativeai as genai
            genai.configure(api_key=gemini_key)
            model = genai.GenerativeModel('gemini-pro') # 或者 gemini-1.5-flash
            response = await model.generate_content_async(prompt)
            return response.text
        except Exception as e:
            print(f"Gemini 调用失败: {e}，尝试 OpenAI...")

    # 备选 OpenAI (DeepSeek/Moonshot 等)
    if openai_key:
        try:
            from openai import AsyncOpenAI
            base_url = os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1")
            client = AsyncOpenAI(api_key=openai_key, base_url=base_url)
            model = os.getenv("OPENAI_MODEL", "gpt-3.5-turbo")
            response = await client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}]
            )
            return response.choices.message.content
        except Exception as e:
            print(f"OpenAI 调用失败: {e}")
            
    return "<li>错误：无法调用 LLM 生成内容，请检查 API Key 配置。</li>"

# --- 3. HTML 模板 (Swiss Style) ---
def generate_swiss_style_html(confirmed_news, rumors, date_str):
    return f"""
    <!DOCTYPE html>
    <html>
    <head>
    <style>
        body {{ font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; background-color: #f0f0f0; color: #333; margin: 0; padding: 20px; }}
        .container {{ max-width: 800px; margin: 0 auto; background: #fff; padding: 40px; border-top: 5px solid #ff4500; }}
        .header {{ margin-bottom: 40px; border-bottom: 2px solid #000; padding-bottom: 20px; }}
        h1 {{ font-size: 36px; font-weight: 700; letter-spacing: -1px; margin: 0; text-transform: uppercase; }}
        .date {{ font-size: 14px; font-weight: 400; color: #666; margin-top: 5px; }}
        .grid-section {{ margin-bottom: 50px; }}
        .section-title {{ font-size: 12px; font-weight: 700; text-transform: uppercase; border-bottom: 1px solid #000; margin-bottom: 20px; padding-bottom: 5px; display: inline-block; }}
        ul {{ list-style-type: none; padding: 0; margin: 0; }}
        li {{ margin-bottom: 15px; font-size: 14px; line-height: 1.4; display: flex; align-items: baseline; }}
        .number {{ font-weight: 700; margin-right: 15px; min-width: 25px; color: #ff4500; }}
        .content {{ color: #000; }}
        .footer {{ font-size: 10px; color: #999; border-top: 1px solid #eee; padding-top: 20px; margin-top: 40px; }}
    </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>Daily Securities Brief</h1>
                <div class="date">{date_str} | China Market Edition</div>
            </div>
            
            <div class="grid-section">
                <div class="section-title">01 / Confirmed News (Reliable Sources)</div>
                <ul>{confirmed_news}</ul>
            </div>
            
            <div class="grid-section">
                <div class="section-title">02 / Market Rumors (Discussions & Speculation)</div>
                <ul>{rumors}</ul>
            </div>
            
            <div class="footer">Generated by AI Stock Analysis System | Source: Global & Local Media</div>
        </div>
    </body>
    </html>
    """

async def run_news_digest():
    print(">>> 开始执行早报新闻抓取...")
    
    try:
        # 1. 搜索
        if not os.getenv("TAVILY_API_KEYS") and not os.getenv("BOCHA_API_KEYS"):
            print("警告: 未检测到搜索 API Key (TAVILY/BOCHA)，搜索可能失败")
            
        searcher = SearchService()
        print("正在搜索权威新闻...")
        results_confirmed = await searcher.search("中国证券市场 最新重磅新闻 过去24小时 新浪财经 东方财富 Reuters Bloomberg SCMP")
        
        print("正在搜索市场传闻...")
        results_rumors = await searcher.search("中国股市 市场传闻 小道消息 资金流向 猜测 过去24小时")
        
        # 2. 生成
        prompt = f"""
        你是一个专业的金融新闻编辑。请根据以下搜索结果，整理两份列表。
        
        [权威新闻源数据]: {results_confirmed}
        [市场传闻源数据]: {results_rumors}
        
        任务：
        1. 提炼20条最重要的中国证券新闻（权威来源）。
        2. 提炼20条最新的市场传闻或热度讨论（未经证实）。
        
        格式要求：
        - 仅输出HTML的 `<li>` 列表项代码。
        - 权威新闻部分用 SECTION_1_START 和 SECTION_1_END 包裹。
        - 传闻部分用 SECTION_2_START 和 SECTION_2_END 包裹。
        - 每一项的格式必须是： <li><span class="number">序号</span><span class="content">一句话概括的内容</span></li>
        - 序号格式如 01, 02...
        - 不要输出 `<ul>` 标签，只要 `<li>`。
        """

        print("正在请求 LLM 进行分析与排版...")
        content = await generate_summary_with_llm(prompt)
        
        # 3. 解析
        try:
            news_part = content.split("SECTION_1_START")[3].split("SECTION_1_END").strip()
        except IndexError:
            news_part = "<li>无法解析新闻内容，LLM 输出格式可能有误。</li>"
            
        try:
            rumor_part = content.split("SECTION_2_START")[3].split("SECTION_2_END").strip()
        except IndexError:
            rumor_part = "<li>无法解析传闻内容，LLM 输出格式可能有误。</li>"

        # 4. 发送
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        html_body = generate_swiss_style_html(news_part, rumor_part, today)
        
        print("正在发送邮件...")
        send_html_email_direct(
            title=f"【证券早报】{today} 市场关键情报",
            html_content=html_body
        )
        
    except Exception:
        print(">>> 运行过程中发生未捕获异常:")
        traceback.print_exc()
        exit(1) # 只有在这里才真正退出报错

if __name__ == "__main__":
    asyncio.run(run_news_digest())
